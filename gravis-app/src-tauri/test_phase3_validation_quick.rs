// Test de validation rapide Phase 3 - Interface complÃ¨te
// Validation: Commandes Tauri + Interface Frontend + Classification

use anyhow::Result;
use tracing::info;

use gravis_app_lib::rag::{
    RagState, DocumentCategory, AdvancedSearchParams,
    OcrConfig, TesseractConfig, PreprocessConfig, CacheConfig
};

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    info!(\"ðŸš€ Test Validation Rapide Phase 3\");
    
    // Test 1: Initialisation systÃ¨me
    let rag_state = RagState::new().await?;\n    info!(\"âœ… SystÃ¨me RAG Phase 3 initialisÃ©\");\n    \n    // Test 2: Commandes Tauri disponibles\n    test_tauri_commands_availability(&rag_state).await?;\n    \n    // Test 3: Classification fonctionnelle\n    test_classification_basic(&rag_state).await?;\n    \n    // Test 4: Recherche avec mÃ©tadonnÃ©es\n    test_search_with_metadata(&rag_state).await?;\n    \n    info!(\"ðŸŽ‰ Validation Phase 3 rÃ©ussie - Interface prÃªte !\");\n    Ok(())\n}\n\nasync fn test_tauri_commands_availability(rag_state: &RagState) -> Result<()> {\n    info!(\"ðŸ”§ Test disponibilitÃ© commandes Tauri\");\n    \n    // Simuler les appels que ferait l'interface frontend\n    \n    // 1. CrÃ©er un groupe de test\n    let group_id = \"validation_quick_test\";\n    \n    // 2. Test cache status (Ã©quivalent Ã  la commande cache_status)\n    let cache_stats = rag_state.unified_cache.get_stats().await;\n    assert!(cache_stats.total_documents >= 0);\n    info!(\"âœ… Cache stats: {} documents en cache\", cache_stats.total_documents);\n    \n    // 3. Test configuration OCR (Ã©quivalent aux paramÃ¨tres frontend)\n    let ocr_config = OcrConfig {\n        tesseract: TesseractConfig {\n            language: \"fra+eng\".to_string(),\n            psm: 6,\n            oem: 3,\n            dpi: Some(300),\n            timeout: std::time::Duration::from_secs(60),\n        },\n        preprocess: PreprocessConfig {\n            enhance_contrast: true,\n            denoise: true,\n            deskew: true,\n            scale_factor: 2.0,\n        },\n        cache: CacheConfig {\n            max_size_mb: 512,\n            ttl_hours: 24,\n            enable_persistence: true,\n        },\n    };\n    \n    info!(\"âœ… Configuration OCR validÃ©e: {}\", ocr_config.tesseract.language);\n    \n    // 4. Test embedder (Ã©quivalent Ã  search_with_metadata)\n    let test_query = \"test embedding\";\n    let _embedding = rag_state.embedder.embed(test_query).await?;\n    info!(\"âœ… Embedder fonctionnel\");\n    \n    info!(\"âœ… Toutes les commandes Tauri disponibles\");\n    Ok(())\n}\n\nasync fn test_classification_basic(rag_state: &RagState) -> Result<()> {\n    info!(\"ðŸ·ï¸  Test classification de base\");\n    \n    // Textes de test pour chaque catÃ©gorie\n    let test_texts = vec![\n        (\"Chiffre d'affaires annuel de 2.5 milliards d'euros, EBITDA en hausse\", DocumentCategory::Business),\n        (\"Article scientifique sur l'intelligence artificielle et machine learning\", DocumentCategory::Academic),\n        (\"Contrat de vente, clauses juridiques et conditions gÃ©nÃ©rales\", DocumentCategory::Legal),\n        (\"Manuel technique de maintenance, spÃ©cifications et procÃ©dures\", DocumentCategory::Technical),\n        (\"Document mixte avec aspects business et techniques\", DocumentCategory::Mixed),\n    ];\n    \n    let mut correct_classifications = 0;\n    \n    for (text, expected_category) in test_texts {\n        let detected_category = rag_state.document_classifier\n            .classify_text(text)\n            .await?;\n        \n        info!(\"ðŸ“„ '{}...' -> {:?} (attendu: {:?})\", \n            &text[..50], detected_category, expected_category);\n        \n        if detected_category == expected_category {\n            correct_classifications += 1;\n        }\n    }\n    \n    let accuracy = correct_classifications as f32 / test_texts.len() as f32;\n    info!(\"ðŸ“Š PrÃ©cision classification: {:.1}% ({}/{})\", \n        accuracy * 100.0, correct_classifications, test_texts.len());\n    \n    // Accepter 60% de prÃ©cision minimum pour validation rapide\n    assert!(accuracy >= 0.6, \"PrÃ©cision classification insuffisante: {:.1}%\", accuracy * 100.0);\n    \n    info!(\"âœ… Classification fonctionnelle\");\n    Ok(())\n}\n\nasync fn test_search_with_metadata(rag_state: &RagState) -> Result<()> {\n    info!(\"ðŸ” Test recherche avec mÃ©tadonnÃ©es\");\n    \n    let group_id = \"validation_quick_test\";\n    \n    // Test avec paramÃ¨tres similaires Ã  l'interface frontend\n    let search_params = AdvancedSearchParams {\n        query: \"business financial revenue\".to_string(),\n        group_id: group_id.to_string(),\n        limit: Some(5),\n        min_score: Some(0.1),\n        document_categories: Some(vec![DocumentCategory::Business]),\n        source_types: None,\n        min_ocr_confidence: Some(0.7),\n    };\n    \n    // Test que la structure de recherche fonctionne (mÃªme si pas de documents)\n    let start_time = std::time::Instant::now();\n    \n    // Pour ce test rapide, on simule juste la construction de la requÃªte\n    let query_embedding = rag_state.embedder.embed(&search_params.query).await?;\n    let search_time = start_time.elapsed();\n    \n    assert!(query_embedding.len() > 0, \"Embedding vide\");\n    assert!(search_time.as_millis() < 1000, \"Embedding trop lent\");\n    \n    info!(\"âœ… Recherche avec mÃ©tadonnÃ©es: embedding {} dims en {}ms\", \n        query_embedding.len(), search_time.as_millis());\n    \n    // Test des filtres de catÃ©gorie\n    let business_filter = search_params.document_categories\n        .as_ref()\n        .unwrap()\n        .iter()\n        .any(|cat| matches!(cat, DocumentCategory::Business));\n    \n    assert!(business_filter, \"Filtre Business non appliquÃ©\");\n    \n    // Test de la confiance OCR minimale\n    assert!(search_params.min_ocr_confidence.unwrap() > 0.0, \"Confiance OCR invalide\");\n    \n    info!(\"âœ… Recherche avec mÃ©tadonnÃ©es fonctionnelle\");\n    Ok(())\n}\n\n/// Test final : simulation d'un workflow complet frontend\n#[allow(dead_code)]\nasync fn test_complete_frontend_workflow(rag_state: &RagState) -> Result<()> {\n    info!(\"ðŸŒ Test workflow frontend complet\");\n    \n    // Ã‰tape 1: L'utilisateur configure OCR dans l'interface\n    let user_ocr_config = OcrConfig {\n        tesseract: TesseractConfig {\n            language: \"fra+eng\".to_string(),\n            psm: 6, // Bloc de texte uniforme\n            oem: 3, // LSTM par dÃ©faut\n            dpi: Some(300),\n            timeout: std::time::Duration::from_secs(120),\n        },\n        preprocess: PreprocessConfig {\n            enhance_contrast: true,\n            denoise: true,\n            deskew: false, // Utilisateur dÃ©sactive le redressement\n            scale_factor: 1.5, // Utilisateur rÃ©duit le facteur d'Ã©chelle\n        },\n        cache: CacheConfig {\n            max_size_mb: 1024,\n            ttl_hours: 48, // Utilisateur augmente la durÃ©e de cache\n            enable_persistence: true,\n        },\n    };\n    \n    info!(\"ðŸ‘¤ Configuration utilisateur: langue={}, psm={}, dpi={}\", \n        user_ocr_config.tesseract.language,\n        user_ocr_config.tesseract.psm,\n        user_ocr_config.tesseract.dpi.unwrap_or(0));\n    \n    // Ã‰tape 2: L'utilisateur sÃ©lectionne des filtres de classification\n    let user_filters = vec![\n        DocumentCategory::Business,\n        DocumentCategory::Technical,\n    ];\n    \n    info!(\"ðŸ·ï¸  Filtres utilisateur: {:?}\", user_filters);\n    \n    // Ã‰tape 3: L'utilisateur fait une recherche\n    let user_query = \"rapport financier technique maintenance\";\n    let search_params = AdvancedSearchParams {\n        query: user_query.to_string(),\n        group_id: \"user_group\".to_string(),\n        limit: Some(10),\n        min_score: Some(0.25),\n        document_categories: Some(user_filters),\n        source_types: Some(vec![\"HybridPdfNative\".to_string(), \"OcrExtracted\".to_string()]),\n        min_ocr_confidence: Some(0.8), // Utilisateur veut haute qualitÃ© OCR\n    };\n    \n    // Valider que tous les paramÃ¨tres sont cohÃ©rents\n    assert!(!search_params.query.is_empty(), \"RequÃªte vide\");\n    assert!(search_params.limit.unwrap() > 0, \"Limite invalide\");\n    assert!(search_params.min_score.unwrap() > 0.0, \"Score minimum invalide\");\n    assert!(search_params.min_ocr_confidence.unwrap() <= 1.0, \"Confiance OCR invalide\");\n    \n    info!(\"âœ… Workflow frontend complet validÃ©\");\n    Ok(())\n}"