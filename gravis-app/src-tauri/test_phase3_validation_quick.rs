// Test de validation rapide Phase 3 - Interface complète
// Validation: Commandes Tauri + Interface Frontend + Classification

use anyhow::Result;
use tracing::info;

use gravis_app_lib::rag::{
    RagState, DocumentCategory, AdvancedSearchParams,
    OcrConfig, TesseractConfig, PreprocessConfig, CacheConfig
};

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    info!(\"🚀 Test Validation Rapide Phase 3\");
    
    // Test 1: Initialisation système
    let rag_state = RagState::new().await?;\n    info!(\"✅ Système RAG Phase 3 initialisé\");\n    \n    // Test 2: Commandes Tauri disponibles\n    test_tauri_commands_availability(&rag_state).await?;\n    \n    // Test 3: Classification fonctionnelle\n    test_classification_basic(&rag_state).await?;\n    \n    // Test 4: Recherche avec métadonnées\n    test_search_with_metadata(&rag_state).await?;\n    \n    info!(\"🎉 Validation Phase 3 réussie - Interface prête !\");\n    Ok(())\n}\n\nasync fn test_tauri_commands_availability(rag_state: &RagState) -> Result<()> {\n    info!(\"🔧 Test disponibilité commandes Tauri\");\n    \n    // Simuler les appels que ferait l'interface frontend\n    \n    // 1. Créer un groupe de test\n    let group_id = \"validation_quick_test\";\n    \n    // 2. Test cache status (équivalent à la commande cache_status)\n    let cache_stats = rag_state.unified_cache.get_stats().await;\n    assert!(cache_stats.total_documents >= 0);\n    info!(\"✅ Cache stats: {} documents en cache\", cache_stats.total_documents);\n    \n    // 3. Test configuration OCR (équivalent aux paramètres frontend)\n    let ocr_config = OcrConfig {\n        tesseract: TesseractConfig {\n            language: \"fra+eng\".to_string(),\n            psm: 6,\n            oem: 3,\n            dpi: Some(300),\n            timeout: std::time::Duration::from_secs(60),\n        },\n        preprocess: PreprocessConfig {\n            enhance_contrast: true,\n            denoise: true,\n            deskew: true,\n            scale_factor: 2.0,\n        },\n        cache: CacheConfig {\n            max_size_mb: 512,\n            ttl_hours: 24,\n            enable_persistence: true,\n        },\n    };\n    \n    info!(\"✅ Configuration OCR validée: {}\", ocr_config.tesseract.language);\n    \n    // 4. Test embedder (équivalent à search_with_metadata)\n    let test_query = \"test embedding\";\n    let _embedding = rag_state.embedder.embed(test_query).await?;\n    info!(\"✅ Embedder fonctionnel\");\n    \n    info!(\"✅ Toutes les commandes Tauri disponibles\");\n    Ok(())\n}\n\nasync fn test_classification_basic(rag_state: &RagState) -> Result<()> {\n    info!(\"🏷️  Test classification de base\");\n    \n    // Textes de test pour chaque catégorie\n    let test_texts = vec![\n        (\"Chiffre d'affaires annuel de 2.5 milliards d'euros, EBITDA en hausse\", DocumentCategory::Business),\n        (\"Article scientifique sur l'intelligence artificielle et machine learning\", DocumentCategory::Academic),\n        (\"Contrat de vente, clauses juridiques et conditions générales\", DocumentCategory::Legal),\n        (\"Manuel technique de maintenance, spécifications et procédures\", DocumentCategory::Technical),\n        (\"Document mixte avec aspects business et techniques\", DocumentCategory::Mixed),\n    ];\n    \n    let mut correct_classifications = 0;\n    \n    for (text, expected_category) in test_texts {\n        let detected_category = rag_state.document_classifier\n            .classify_text(text)\n            .await?;\n        \n        info!(\"📄 '{}...' -> {:?} (attendu: {:?})\", \n            &text[..50], detected_category, expected_category);\n        \n        if detected_category == expected_category {\n            correct_classifications += 1;\n        }\n    }\n    \n    let accuracy = correct_classifications as f32 / test_texts.len() as f32;\n    info!(\"📊 Précision classification: {:.1}% ({}/{})\", \n        accuracy * 100.0, correct_classifications, test_texts.len());\n    \n    // Accepter 60% de précision minimum pour validation rapide\n    assert!(accuracy >= 0.6, \"Précision classification insuffisante: {:.1}%\", accuracy * 100.0);\n    \n    info!(\"✅ Classification fonctionnelle\");\n    Ok(())\n}\n\nasync fn test_search_with_metadata(rag_state: &RagState) -> Result<()> {\n    info!(\"🔍 Test recherche avec métadonnées\");\n    \n    let group_id = \"validation_quick_test\";\n    \n    // Test avec paramètres similaires à l'interface frontend\n    let search_params = AdvancedSearchParams {\n        query: \"business financial revenue\".to_string(),\n        group_id: group_id.to_string(),\n        limit: Some(5),\n        min_score: Some(0.1),\n        document_categories: Some(vec![DocumentCategory::Business]),\n        source_types: None,\n        min_ocr_confidence: Some(0.7),\n    };\n    \n    // Test que la structure de recherche fonctionne (même si pas de documents)\n    let start_time = std::time::Instant::now();\n    \n    // Pour ce test rapide, on simule juste la construction de la requête\n    let query_embedding = rag_state.embedder.embed(&search_params.query).await?;\n    let search_time = start_time.elapsed();\n    \n    assert!(query_embedding.len() > 0, \"Embedding vide\");\n    assert!(search_time.as_millis() < 1000, \"Embedding trop lent\");\n    \n    info!(\"✅ Recherche avec métadonnées: embedding {} dims en {}ms\", \n        query_embedding.len(), search_time.as_millis());\n    \n    // Test des filtres de catégorie\n    let business_filter = search_params.document_categories\n        .as_ref()\n        .unwrap()\n        .iter()\n        .any(|cat| matches!(cat, DocumentCategory::Business));\n    \n    assert!(business_filter, \"Filtre Business non appliqué\");\n    \n    // Test de la confiance OCR minimale\n    assert!(search_params.min_ocr_confidence.unwrap() > 0.0, \"Confiance OCR invalide\");\n    \n    info!(\"✅ Recherche avec métadonnées fonctionnelle\");\n    Ok(())\n}\n\n/// Test final : simulation d'un workflow complet frontend\n#[allow(dead_code)]\nasync fn test_complete_frontend_workflow(rag_state: &RagState) -> Result<()> {\n    info!(\"🌐 Test workflow frontend complet\");\n    \n    // Étape 1: L'utilisateur configure OCR dans l'interface\n    let user_ocr_config = OcrConfig {\n        tesseract: TesseractConfig {\n            language: \"fra+eng\".to_string(),\n            psm: 6, // Bloc de texte uniforme\n            oem: 3, // LSTM par défaut\n            dpi: Some(300),\n            timeout: std::time::Duration::from_secs(120),\n        },\n        preprocess: PreprocessConfig {\n            enhance_contrast: true,\n            denoise: true,\n            deskew: false, // Utilisateur désactive le redressement\n            scale_factor: 1.5, // Utilisateur réduit le facteur d'échelle\n        },\n        cache: CacheConfig {\n            max_size_mb: 1024,\n            ttl_hours: 48, // Utilisateur augmente la durée de cache\n            enable_persistence: true,\n        },\n    };\n    \n    info!(\"👤 Configuration utilisateur: langue={}, psm={}, dpi={}\", \n        user_ocr_config.tesseract.language,\n        user_ocr_config.tesseract.psm,\n        user_ocr_config.tesseract.dpi.unwrap_or(0));\n    \n    // Étape 2: L'utilisateur sélectionne des filtres de classification\n    let user_filters = vec![\n        DocumentCategory::Business,\n        DocumentCategory::Technical,\n    ];\n    \n    info!(\"🏷️  Filtres utilisateur: {:?}\", user_filters);\n    \n    // Étape 3: L'utilisateur fait une recherche\n    let user_query = \"rapport financier technique maintenance\";\n    let search_params = AdvancedSearchParams {\n        query: user_query.to_string(),\n        group_id: \"user_group\".to_string(),\n        limit: Some(10),\n        min_score: Some(0.25),\n        document_categories: Some(user_filters),\n        source_types: Some(vec![\"HybridPdfNative\".to_string(), \"OcrExtracted\".to_string()]),\n        min_ocr_confidence: Some(0.8), // Utilisateur veut haute qualité OCR\n    };\n    \n    // Valider que tous les paramètres sont cohérents\n    assert!(!search_params.query.is_empty(), \"Requête vide\");\n    assert!(search_params.limit.unwrap() > 0, \"Limite invalide\");\n    assert!(search_params.min_score.unwrap() > 0.0, \"Score minimum invalide\");\n    assert!(search_params.min_ocr_confidence.unwrap() <= 1.0, \"Confiance OCR invalide\");\n    \n    info!(\"✅ Workflow frontend complet validé\");\n    Ok(())\n}"