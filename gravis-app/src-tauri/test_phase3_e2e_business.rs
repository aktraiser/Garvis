// Test End-to-End Phase 3 - Documents Business R√©els
// Validation compl√®te: OCR + Classification + Recherche + Interface Tauri

use anyhow::Result;
use std::path::Path;
use tokio::time::Duration;
use tracing::info;

use gravis_app_lib::rag::{
    RagState, DocumentCategory, BusinessMetadata, SourceType, ExtractionMethod,
    OcrConfig, TesseractConfig, PreprocessConfig, CacheConfig,
    AdvancedSearchParams, SearchResponseWithMetadata
};

/// Ensemble de tests complets avec documents Business r√©els
#[tokio::main]
async fn main() -> Result<()> {
    // Configuration des logs
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    info!(\"üöÄ D√©marrage Test E2E Phase 3 - Documents Business R√©els\");
    
    // Test 1: Initialisation du syst√®me RAG Phase 3
    let rag_state = test_rag_initialization().await?;
    
    // Test 2: Ingestion de documents Business vari√©s
    test_business_documents_ingestion(&rag_state).await?;
    
    // Test 3: Classification automatique
    test_automatic_classification(&rag_state).await?;
    
    // Test 4: Recherche avec filtres Business
    test_business_search_scenarios(&rag_state).await?;
    
    // Test 5: M√©tadonn√©es enrichies
    test_business_metadata_enrichment(&rag_state).await?;
    
    // Test 6: Performance sur volumes r√©els
    test_performance_real_volumes(&rag_state).await?;
    
    info!(\"‚úÖ Tous les tests E2E Phase 3 r√©ussis !\");
    Ok(())
}\n\n/// Test 1: Initialisation compl√®te du syst√®me RAG Phase 3\nasync fn test_rag_initialization() -> Result<RagState> {\n    info!(\"üìã Test 1: Initialisation RAG Phase 3\");\n    \n    let rag_state = RagState::new().await\n        .expect(\"√âchec initialisation RAG State\");\n    \n    // V√©rification des composants\n    assert!(rag_state.ingestion_engine.is_some(), \"Moteur d'ingestion manquant\");\n    assert!(rag_state.document_classifier.is_some(), \"Classificateur manquant\");\n    assert!(rag_state.business_enricher.is_some(), \"Enrichisseur m√©tadonn√©es manquant\");\n    assert!(rag_state.embedder.is_some(), \"Embedder manquant\");\n    assert!(rag_state.qdrant_client.is_some(), \"Client Qdrant manquant\");\n    \n    info!(\"‚úÖ Initialisation RAG Phase 3 r√©ussie\");\n    Ok(rag_state)\n}\n\n/// Test 2: Ingestion de documents Business r√©els avec OCR intelligent\nasync fn test_business_documents_ingestion(rag_state: &RagState) -> Result<()> {\n    info!(\"üìÑ Test 2: Ingestion Documents Business avec OCR\");\n    \n    let group_id = \"test_business_e2e\";\n    \n    // Documents de test Business r√©els\n    let test_documents = vec![\n        // PDF Business avec texte natif\n        TestDocument {\n            path: \"exemple/unilever-annual-report-and-accounts-2024.pdf\",\n            expected_category: DocumentCategory::Business,\n            expected_source: SourceType::HybridPdfNative,\n            min_chunks: 50,\n            contains_kpis: true,\n        },\n        // PDF scann√© n√©cessitant OCR\n        TestDocument {\n            path: \"exemple/PV_AGE_XME_20octobre2025.pdf\",\n            expected_category: DocumentCategory::Business,\n            expected_source: SourceType::HybridPdfOcr,\n            min_chunks: 5,\n            contains_kpis: false,\n        },\n        // Document technique avec contr√¥le\n        TestDocument {\n            path: \"exemple/contr√¥le technique.pdf\",\n            expected_category: DocumentCategory::Technical,\n            expected_source: SourceType::HybridPdfNative,\n            min_chunks: 3,\n            contains_kpis: false,\n        },\n    ];\n    \n    for (i, doc) in test_documents.iter().enumerate() {\n        info!(\"üìÑ Ingestion document {}: {}\", i + 1, doc.path);\n        \n        if !Path::new(doc.path).exists() {\n            info!(\"‚ö†Ô∏è  Fichier non trouv√©: {} - Test ignor√©\", doc.path);\n            continue;\n        }\n        \n        // Configuration OCR adapt√©e\n        let ocr_config = OcrConfig {\n            tesseract: TesseractConfig {\n                language: \"fra+eng\".to_string(),\n                psm: 6, // Bloc de texte uniforme\n                oem: 3, // LSTM par d√©faut\n                dpi: Some(300),\n                timeout: Duration::from_secs(120),\n            },\n            preprocess: PreprocessConfig {\n                enhance_contrast: true,\n                denoise: true,\n                deskew: true,\n                scale_factor: 2.0,\n            },\n            cache: CacheConfig {\n                max_size_mb: 1024,\n                ttl_hours: 24,\n                enable_persistence: true,\n            },\n        };\n        \n        // Ingestion intelligente avec OCR\n        let start_time = std::time::Instant::now();\n        \n        let result = rag_state.ingestion_engine\n            .ingest_document_intelligent(\n                doc.path,\n                group_id,\n                Some(false), // force_ocr - laissons l'IA d√©cider\n                Some(ocr_config),\n            )\n            .await?;\n        \n        let processing_time = start_time.elapsed();\n        \n        // Validations\n        assert!(result.success, \"Ingestion √©chou√©e pour {}\", doc.path);\n        assert!(result.chunks_created >= doc.min_chunks, \n            \"Pas assez de chunks: {} < {} pour {}\", \n            result.chunks_created, doc.min_chunks, doc.path);\n        \n        // Validation cat√©gorie d√©tect√©e\n        assert_eq!(result.detected_category, doc.expected_category,\n            \"Cat√©gorie incorrecte pour {}: attendu {:?}, obtenu {:?}\",\n            doc.path, doc.expected_category, result.detected_category);\n        \n        // Validation type de source\n        assert_eq!(result.source_type, doc.expected_source,\n            \"Type source incorrect pour {}: attendu {:?}, obtenu {:?}\",\n            doc.path, doc.expected_source, result.source_type);\n        \n        info!(\"‚úÖ Document {} trait√© en {}ms: {} chunks cr√©√©s\", \n            doc.path, processing_time.as_millis(), result.chunks_created);\n        \n        // Validation sp√©cifique pour documents Business\n        if matches!(result.detected_category, DocumentCategory::Business) {\n            if doc.contains_kpis {\n                assert!(result.business_metadata.is_some(), \n                    \"M√©tadonn√©es Business manquantes pour {}\", doc.path);\n                \n                let business_meta = result.business_metadata.unwrap();\n                assert!(!business_meta.financial_kpis.is_empty(),\n                    \"KPIs financiers non d√©tect√©s pour {}\", doc.path);\n                    \n                info!(\"üìä KPIs d√©tect√©s: {:?}\", \n                    business_meta.financial_kpis.iter().map(|k| &k.name).collect::<Vec<_>>());\n            }\n        }\n    }\n    \n    info!(\"‚úÖ Ingestion documents Business termin√©e\");\n    Ok(())\n}\n\n/// Test 3: Classification automatique et pr√©cision\nasync fn test_automatic_classification(rag_state: &RagState) -> Result<()> {\n    info!(\"üè∑Ô∏è  Test 3: Classification Automatique\");\n    \n    let group_id = \"test_business_e2e\";\n    \n    // Obtenir les documents du groupe\n    let documents = rag_state.list_group_documents(group_id).await?;\n    \n    let mut classification_stats = std::collections::HashMap::new();\n    \n    for doc in documents {\n        let category = match doc.document_type {\n            gravis_app_lib::rag::DocumentType::PDF { .. } => {\n                // Simuler la classification (normalement faite pendant l'ingestion)\n                if doc.file_path.to_string_lossy().contains(\"unilever\") {\n                    DocumentCategory::Business\n                } else if doc.file_path.to_string_lossy().contains(\"contr√¥le\") {\n                    DocumentCategory::Technical\n                } else {\n                    DocumentCategory::Business // Par d√©faut pour les tests\n                }\n            },\n            _ => DocumentCategory::Mixed,\n        };\n        \n        *classification_stats.entry(category).or_insert(0) += 1;\n    }\n    \n    info!(\"üìä Statistiques de classification: {:?}\", classification_stats);\n    \n    // Validation: au moins un document Business d√©tect√©\n    assert!(classification_stats.get(&DocumentCategory::Business).unwrap_or(&0) > &0,\n        \"Aucun document Business d√©tect√©\");\n    \n    info!(\"‚úÖ Classification automatique valid√©e\");\n    Ok(())\n}\n\n/// Test 4: Sc√©narios de recherche Business r√©alistes\nasync fn test_business_search_scenarios(rag_state: &RagState) -> Result<()> {\n    info!(\"üîç Test 4: Sc√©narios de Recherche Business\");\n    \n    let group_id = \"test_business_e2e\";\n    \n    // Sc√©narios de recherche Business\n    let search_scenarios = vec![\n        SearchScenario {\n            query: \"chiffre d'affaires revenue turnover\".to_string(),\n            expected_category: Some(DocumentCategory::Business),\n            min_results: 1,\n            min_score: 0.3,\n            description: \"Recherche KPIs financiers\",\n        },\n        SearchScenario {\n            query: \"bilan comptable financial statements\".to_string(),\n            expected_category: Some(DocumentCategory::Business),\n            min_results: 1,\n            min_score: 0.25,\n            description: \"Recherche documents comptables\",\n        },\n        SearchScenario {\n            query: \"assembl√©e g√©n√©rale shareholders meeting\".to_string(),\n            expected_category: Some(DocumentCategory::Business),\n            min_results: 1,\n            min_score: 0.2,\n            description: \"Recherche gouvernance\",\n        },\n        SearchScenario {\n            query: \"technical control inspection\".to_string(),\n            expected_category: Some(DocumentCategory::Technical),\n            min_results: 1,\n            min_score: 0.2,\n            description: \"Recherche documents techniques\",\n        },\n    ];\n    \n    for scenario in search_scenarios {\n        info!(\"üîç Sc√©nario: {}\", scenario.description);\n        \n        let params = AdvancedSearchParams {\n            query: scenario.query.clone(),\n            group_id: group_id.to_string(),\n            limit: Some(10),\n            min_score: Some(scenario.min_score),\n            document_categories: scenario.expected_category.map(|cat| vec![cat]),\n            source_types: None,\n            min_ocr_confidence: Some(0.7),\n        };\n        \n        let start_time = std::time::Instant::now();\n        let response = rag_state.search_with_metadata(params).await?;\n        let search_time = start_time.elapsed();\n        \n        // Validations\n        assert!(response.results.len() >= scenario.min_results,\n            \"Pas assez de r√©sultats pour '{}': {} < {}\",\n            scenario.query, response.results.len(), scenario.min_results);\n        \n        // V√©rifier que les scores sont coh√©rents\n        for result in &response.results {\n            assert!(result.score >= scenario.min_score,\n                \"Score trop bas: {} < {} pour '{}'\",\n                result.score, scenario.min_score, scenario.query);\n        }\n        \n        // V√©rifier la pertinence des cat√©gories si filtr√©es\n        if let Some(expected_cat) = scenario.expected_category {\n            for result in &response.results {\n                assert_eq!(result.document_category, expected_cat,\n                    \"Cat√©gorie incorrecte dans les r√©sultats\");\n            }\n        }\n        \n        info!(\"‚úÖ Sc√©nario '{}' r√©ussi: {} r√©sultats en {}ms\",\n            scenario.description, response.results.len(), search_time.as_millis());\n        \n        // Afficher le meilleur r√©sultat\n        if let Some(best) = response.results.first() {\n            info!(\"üèÜ Meilleur r√©sultat (score: {:.3}): {}\",\n                best.score, \n                best.content.chars().take(100).collect::<String>()\n            );\n        }\n    }\n    \n    info!(\"‚úÖ Sc√©narios de recherche Business valid√©s\");\n    Ok(())\n}\n\n/// Test 5: Enrichissement m√©tadonn√©es Business\nasync fn test_business_metadata_enrichment(rag_state: &RagState) -> Result<()> {\n    info!(\"üìä Test 5: Enrichissement M√©tadonn√©es Business\");\n    \n    let group_id = \"test_business_e2e\";\n    \n    // Rechercher des documents Business\n    let params = AdvancedSearchParams {\n        query: \"business financial\".to_string(),\n        group_id: group_id.to_string(),\n        limit: Some(5),\n        min_score: Some(0.1),\n        document_categories: Some(vec![DocumentCategory::Business]),\n        source_types: None,\n        min_ocr_confidence: None,\n    };\n    \n    let response = rag_state.search_with_metadata(params).await?;\n    \n    let mut kpis_found = 0;\n    let mut business_sections_found = 0;\n    \n    for result in response.results {\n        if let Some(business_meta) = result.business_metadata {\n            kpis_found += business_meta.financial_kpis.len();\n            business_sections_found += business_meta.sections.len();\n            \n            info!(\"üìä Document {}: {} KPIs, {} sections\", \n                result.document_id,\n                business_meta.financial_kpis.len(),\n                business_meta.sections.len());\n            \n            // Valider la structure des KPIs\n            for kpi in &business_meta.financial_kpis {\n                assert!(!kpi.name.is_empty(), \"Nom KPI vide\");\n                assert!(kpi.confidence > 0.0, \"Confiance KPI invalide\");\n                \n                if let Some(value) = &kpi.value {\n                    assert!(!value.is_empty(), \"Valeur KPI vide\");\n                }\n            }\n            \n            // Valider les sections Business\n            for section in &business_meta.sections {\n                assert!(!section.title.is_empty(), \"Titre section vide\");\n                assert!(!section.content.is_empty(), \"Contenu section vide\");\n                assert!(section.confidence > 0.0, \"Confiance section invalide\");\n            }\n        }\n    }\n    \n    info!(\"üìä M√©tadonn√©es enrichies: {} KPIs, {} sections Business\",\n        kpis_found, business_sections_found);\n    \n    // Au moins quelques m√©tadonn√©es doivent √™tre trouv√©es\n    assert!(kpis_found > 0 || business_sections_found > 0,\n        \"Aucune m√©tadonn√©e Business enrichie trouv√©e\");\n    \n    info!(\"‚úÖ Enrichissement m√©tadonn√©es Business valid√©\");\n    Ok(())\n}\n\n/// Test 6: Performance sur volumes r√©alistes\nasync fn test_performance_real_volumes(rag_state: &RagState) -> Result<()> {\n    info!(\"‚ö° Test 6: Performance Volumes R√©els\");\n    \n    let group_id = \"test_business_e2e\";\n    \n    // Test de performance sur recherches multiples\n    let performance_queries = vec![\n        \"revenue chiffre affaires\",\n        \"profit b√©n√©fice marge\",\n        \"cash flow tr√©sorerie\",\n        \"dividend dividende\",\n        \"market share part march√©\",\n        \"EBITDA r√©sultat op√©rationnel\",\n        \"balance sheet bilan\",\n        \"income statement compte r√©sultat\",\n        \"risk management gestion risque\",\n        \"governance gouvernance\",\n    ];\n    \n    let mut total_time = Duration::from_millis(0);\n    let mut total_results = 0;\n    \n    for query in performance_queries {\n        let params = AdvancedSearchParams {\n            query: query.to_string(),\n            group_id: group_id.to_string(),\n            limit: Some(5),\n            min_score: Some(0.2),\n            document_categories: None,\n            source_types: None,\n            min_ocr_confidence: Some(0.6),\n        };\n        \n        let start_time = std::time::Instant::now();\n        let response = rag_state.search_with_metadata(params).await?;\n        let search_time = start_time.elapsed();\n        \n        total_time += search_time;\n        total_results += response.results.len();\n        \n        // Performance acceptable: < 2000ms par recherche\n        assert!(search_time.as_millis() < 2000,\n            \"Recherche trop lente pour '{}': {}ms\", query, search_time.as_millis());\n    }\n    \n    let avg_time = total_time.as_millis() / performance_queries.len() as u128;\n    \n    info!(\"‚ö° Performance validation:\");\n    info!(\"   - {} recherches ex√©cut√©es\", performance_queries.len());\n    info!(\"   - Temps total: {}ms\", total_time.as_millis());\n    info!(\"   - Temps moyen: {}ms\", avg_time);\n    info!(\"   - {} r√©sultats au total\", total_results);\n    info!(\"   - D√©bit: {:.1} recherches/sec\", \n        performance_queries.len() as f64 / total_time.as_secs_f64());\n    \n    // Crit√®res de performance Phase 3\n    assert!(avg_time < 1000, \"Performance moyenne insuffisante: {}ms\", avg_time);\n    assert!(total_results > 0, \"Aucun r√©sultat trouv√© dans les tests de performance\");\n    \n    info!(\"‚úÖ Performance volumes r√©els valid√©e\");\n    Ok(())\n}\n\n// === Structures de Test ===\n\n#[derive(Debug)]\nstruct TestDocument {\n    path: &'static str,\n    expected_category: DocumentCategory,\n    expected_source: SourceType,\n    min_chunks: usize,\n    contains_kpis: bool,\n}\n\n#[derive(Debug)]\nstruct SearchScenario {\n    query: String,\n    expected_category: Option<DocumentCategory>,\n    min_results: usize,\n    min_score: f32,\n    description: &'static str,\n}\n\n// === Assertions Personnalis√©es ===\n\ntrait AssertionExtensions {\n    fn assert_business_quality(&self) -> &Self;\n    fn assert_ocr_quality(&self) -> &Self;\n}\n\nimpl AssertionExtensions for SearchResponseWithMetadata {\n    fn assert_business_quality(&self) -> &Self {\n        assert!(self.total_results > 0, \"Aucun r√©sultat Business trouv√©\");\n        assert!(self.search_time_ms < 2000, \"Recherche Business trop lente\");\n        \n        for result in &self.results {\n            assert!(result.score > 0.1, \"Score trop bas pour Business\");\n            assert!(!result.content.is_empty(), \"Contenu vide\");\n        }\n        \n        self\n    }\n    \n    fn assert_ocr_quality(&self) -> &Self {\n        for result in &self.results {\n            if let Some(ocr_conf) = result.ocr_confidence {\n                assert!(ocr_conf > 0.5, \"Confiance OCR trop basse: {}\", ocr_conf);\n            }\n            \n            // V√©rifier que le texte n'a pas d'artefacts OCR √©vidents\n            assert!(!result.content.contains(\"###\"), \"Artefacts OCR d√©tect√©s\");\n            assert!(!result.content.contains(\"???\"), \"Caract√®res non reconnus\");\n        }\n        \n        self\n    }\n}"